//=======================================================================
// 프로젝트명 /node_modules/react 안에 default 가 붙어 수출하는 
    // 컴포넌트를 수입해서 현재 파일 안에서 React 란 이름으로 사용
// 프로젝트명 /node_modules/react 안에 default 가 안 붙어 수출하는 
    // 컴포넌트를 수입해서 현재 파일 안에서 Component 란 이름으로 사용
//----------------------------------------------------------
// <참고> 아래 수입 코드는 클래스 컴포넌트가 선언되는 js 파일 안에서는 필수로 수입되는 컴포넌트들이다.
//=======================================================================
import React, {Component} from 'react';

//=======================================================================
// 리액트의 단위 프로그램 중 하나인 [클래스 컴포넌트] 선언하기
// <참고> [클래스 컴포넌트]는 자바의 클래스와 유사한 형태를 가지고 있다.
// <주의> [클래스 컴포넌트]는 반드시 Component 클래스를 상속해야 한다.
//=======================================================================
class Counter extends Component {

    //----------------------------------------------------------
    // 사용자 정의 속성변수 선언하기 
    // <주의> 사용자 정의 속성변수 선언 시 this. 을 붙이지 않는다.
    // <주의> 호출 시 this. 을 붙인다.
    //----------------------------------------------------------
    default_number = 0;

    //----------------------------------------------------------
    // 리액트가 제공하는 state 속성변수 선언하고 [사용자정의 객체]를 저장하기
    //----------------------------------------------------------
    // 클래스 컴포넌트 안에서 리액트가 제공하는 state 속성변수 특징
    // ★★★state 속성변수의 갱신은 리액트가 제공하는 setState 메소드 호출로만 가능하다.
    // ★★★setState 메소드 호출로 state 속성변수 안의 값이 갱신되면 render 메소드가 재호출된다.
    // state 속성변수 호출할 경우 this. 을 붙인다.
    //----------------------------------------------------------
    state = {
        // 사용자 정의 객체 안에 속성변수 start_number 선언하고 
        // 바깥쪽 속성변수 default_number 안의 값을 저장하기
        start_number : this.default_number  
        , now_number : this.default_number
    };
    
    //----------------------------------------------------------
    // 사용자 정의 속성변수 add에 화살표 함수 저장하기
    //----------------------------------------------------------
    add = () => {
        // setState 라는 메소드 호출하여 state 변수 안에 저장된 사용자 정의 객체
        // 안의 속성변수 now_number 안의 데이터를 this.state.now_number+1 의 실행결과로 갱신하라
        // <주의> state 변수 안에 저장된 사용자 정의 객체가 
        //    {now_number: this.state.now_number+1} 갱신 된게 절대 아니다.
        //    즉, 부분 갱신만 진행된 것이다.
        this.setState (
            {now_number: this.state.now_number+1}
        );
    };

    //----------------------------------------------------------
    // 사용자 정의 속성변수 minus 에 화살표 함수 저장하기
    //----------------------------------------------------------
    minus = () => {
        this.setState(
            {now_number: this.state.now_number-1}
        );
    };

    //----------------------------------------------------------
    // 사용자 정의 속성변수 init에 화살표 함수 저장히기
    //----------------------------------------------------------
    init = () => {
        this.setState(
            {now_number: this.state.start_number}
        );
    };

    //----------------------------------------------------------
    // render 메소드 필수 1개 선언
    //----------------------------------------------------------
    render() {
        //----------------------------------------------------------
        // render 메소드 안에서만 사용 가능한 지역변수 start_number, now_number 선언하고
        // 지역변수 start_number에는 state 변수 안의 사용자 정의 객체 안의 statr_number 속성변수의 값 저장하기
        // 지역변수 now_number에는 state 변수 안의 사용자 정의 객체 안의 now_number 속성변수의 값 저장하기
        //----------------------------------------------------------
        // 즉, 지역변수명과 일치하는 사용자 정의 객체의 속성변수 안의 값을 지역변수에 저장하기
        //----------------------------------------------------------
        // <참고> 아래 코딩을 달리해 표현한다면 이와 같다. 
        // const start_number = this.state.start_number
        // const now_number = this.state.now_number
        //----------------------------------------------------------
        const {start_number, now_number} = this.state;

        //----------------------------------------------------------
        // return 구문 필수 선언
        //----------------------------------------------------------
        return (
            <>
                <center>
                    {/*--------------------------------------------*/}
                    {/* render 메소드 안에 선언된 start_number 라는 지역변수 안의 값을 표현하기 */}
                    {/* render 메소드 안에 선언된 now_number 라는 지역변수 안의 값을 표현하기 */}
                    {/*--------------------------------------------*/}
                    시작값 : {start_number} <br/>
                    현재값 : {now_number} <br/>
                    {/* +1이 들어간 버튼을 클릭하면 속성변수 add 안의 화살표 함수 안의 코딩을 실행하기*/}
                    {/* -1이 들어간 버튼을 클릭하면 속성변수 minus 안의 화살표 함수 안의 코딩을 실행하기*/}
                    {/* 초기값으로 들어간 버튼을 클릭하면 속성변수 init 안의 화살표 함수 안의 코딩을 실행하기*/}
                    <button onClick={this.add}>+1</button> &nbsp; 
                    <button onClick={this.minus}>-1</button> &nbsp; 
                    <button onClick={this.init}>초기값으로</button> 
                </center>
            </> 
        );
    }
}

//=======================================================================
// 현재 이 파일 안에서 기본적으로 수출할 컴포넌트 지정하기
//=======================================================================
export default Counter;

/*
----------------------------------------------------------
<문제1> 위에 있는 Counter 클래스 컴포넌트는 지금 어디서 누가 호출했나?
----------------------------------------------------------
URL 주소가 ~:3000/naver/counter 일 경우
App.js에서 아래 코딩에 의해 호출되었다.
<Route path="/naver/counter" component = {Counter}/>

----------------------------------------------------------
<문제2> 위에 있는 Counter 클래스 컴포넌트가 호출되면(=실행되면) 어떤 일이 벌어지나?
----------------------------------------------------------
(1) 생성자가 있으면 생성자를 호출한다.
(2) 속성변수하고 메소드를 읽어 들인다.
(3) render 메소드를 호출한다.
(4) render 메소드가 리턴하는 JSX 문법을 [화면 출력 기능의 자바스크립트]로 바꾸고 클라이언트의 브라우저로 전송한다.
(5) 클라이언트 브라우저가 [화면 출력 기능의 자바스크립트]를 읽어 들여 화면에 출력한다.
----------------------------------------------------------
(6) ★★★만약, 이벤트가 발생하여 자스 코딩이 실행되는 과정에서 [setState 메소드]가 호출되어
    state 속성변수 안의 값이 데이터가 변경되면 [render 메소드]를 재 호출한다.
    재 호출되어 출력되는 콘텐츠가 이전 화면 콘텐츠를 갱신하는게 아니라 
    달라진 부분만 갱신 시켜 버린다. 리로드가 아니다. 
    ----------------------------------------------------------
    즉, 화면에 부분 변화를 일으키고 싶다면 이벤트에 의해 실행되는
    자스 코딩 안에 [setState 메소드]가 호출되게 만들어 버리면 된다.
    리액트가 아닌 HTML 이나 JSP에서의 자스에서도 이런 효과를 볼 수는 있지만
    그러나, 리액트 보다는 일부 화면 변화 시 부하가 훨씬 더 걸린다.
    ----------------------------------------------------------
    
----------------------------------------------------------
<문제3> const {start_number, now_number} = this.state; 코딩의 의미는?
----------------------------------------------------------
지역변수명과 일치하는 사용자 정의 객체의 속성변수 안의 값을 지역변수에 저장하기
달리해 표현한다면 이와 같다. 
const start_number = this.state.start_number;
const now_number = this.state.now_number;

----------------------------------------------------------
<문제4> <br/> 를 <br>로 고치면?
----------------------------------------------------------
완벽한 에러가 발생한다. 화면에 출력되지 않을 정도의 에러가 발생한다.
JSX 문법의 1순위 모든 태그는 여는 태그가 있으면 후에 닫는 태그가 반드시 꼭 나와야 한다.
여는 태그만 있는 태그는 여는 태그 마지막에 / 나와야 한다.
현재 <br> 는 여는 태그만 있는 태그이므로 <br/>로 해야 에러가 없다.

----------------------------------------------------------
<문제5> <> 와 </>를 생략하면?
----------------------------------------------------------
에러 없다. <> 와 </>를 생략하면 <center> 태그 하나가 최상위 태그가 되므로 에러가 없다.

----------------------------------------------------------
<문제6> const, var, let 은 무엇인가?
----------------------------------------------------------
변수 선언 시 변수 왼쪽에 붙이는 키워드이다.

*/